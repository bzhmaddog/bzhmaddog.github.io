var S=Object.defineProperty;var L=(u,i,e)=>i in u?S(u,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[i]=e;var a=(u,i,e)=>(L(u,typeof i!="symbol"?i+"":i,e),e);(function(){const i=document.createElement("link").relList;if(i&&i.supports&&i.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))t(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const n of r.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&t(n)}).observe(document,{childList:!0,subtree:!0});function e(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function t(s){if(s.ep)return;s.ep=!0;const r=e(s);fetch(s.href,r)}})();class A{static easeLinear(i,e,t,s){return t*i/s+e}static easeOutQuad(i,e,t,s){return-t*(i/=s)*(i-2)+e}static easeOutSine(i,e,t,s){return t*Math.sin(i/s*(Math.PI/2))+e}static easeInSine(i,e,t,s){return-t*Math.cos(i/s*(Math.PI/2))+t+e}}class B{constructor(i,e,t=!0){a(this,"_canvas");a(this,"_context");this._canvas=document.createElement("canvas"),this._canvas.width=i,this._canvas.height=e;let s=null;t&&(s={willReadFrequently:!0}),this._context=this._canvas.getContext("2d",s)}get context(){return this._context}get canvas(){return this._canvas}get width(){return this._canvas.width}get height(){return this._canvas.height}set width(i){this._canvas.width=i}set height(i){this._canvas.height=i}clear(){this._context.clearRect(0,0,this._canvas.width,this._canvas.height)}}class m extends Map{constructor(i){super(),i&&this._merge(i,this)}merge(i){const e=new m(this);return i&&this._merge(i,e),e}_merge(i,e){if(i instanceof m)for(const[t,s]of i.entries())e.set(t,s);else if(i instanceof Map){const t=Object.fromEntries(i);Object.keys(t).forEach(s=>{e.set(s,t[s])})}else typeof i=="object"&&Object.keys(i).forEach(t=>{e.set(t,i[t])})}}class C{constructor(i,e,t,s){a(this,"_id");a(this,"_buffer");a(this,"_spriteSheet");a(this,"_animations");a(this,"_animation");a(this,"_isAnimating");a(this,"_loop");a(this,"_queue");a(this,"_loopSequence");a(this,"_hFrameOffset");a(this,"_vFrameOffset");a(this,"_maxHeight");a(this,"_maxWidth");a(this,"_endOfQueueListener");a(this,"_frameDuration");a(this,"_frameIndex");a(this,"_startTime");this._id=i,this._buffer=new B(0,0),this._animations={},this._animation=null,this._isAnimating=!1,this._loop=1,this._queue=[],this._loopSequence=!1,this._maxHeight=0,this._maxWidth=0,this._frameIndex=0,this._frameDuration=0,this._hFrameOffset=t,this._vFrameOffset=s,this._spriteSheet=e}addAnimation(i,e){if(typeof this._animations[i]>"u")this._animations[i]=e,this._maxHeight=Math.max(this._maxHeight,e.height),this._maxWidth=Math.max(this._maxWidth,e.width);else throw new Error(`Animation [${i} already exists in sprite [${this._id}]`)}_doAnimation(i){const e=i,t=this._frameIndex;this._startTime===null&&(this._startTime=e);const s=e-this._startTime;if(this._frameIndex=Math.floor(s/this._frameDuration),this._frameIndex>=this._animation.params.nbFrames){if(this._loop++,this._animation.loop>0&&this._loop>this._animation.loop){this._processQueue();return}this._frameIndex=0,this._startTime=null}if(this._frameIndex!==t){const r=this._frameIndex*(this._animation.params.width+this._hFrameOffset)+this._animation.params.xOffset,n=this._maxHeight-this._animation.params.height;this._buffer.clear(),this._buffer.context.drawImage(this._spriteSheet,r,this._animation.params.yOffset,this._animation.params.width,this._animation.params.height,0,n,this._animation.params.width,this._animation.params.height)}requestAnimationFrame(this._doAnimation.bind(this))}_processQueue(){this._queue.length>0?(this._loopSequence?this._queue.length>1?(this._animation=this._queue.shift(),this._queue.push(this._animation)):this._animation=this._queue[0]:this._animation=this._queue.shift(),this._frameIndex=this._animation.params.nbFrames,this._startTime=null,this._frameDuration=this._animation.params.duration/this._animation.params.nbFrames,this._isAnimating=!0,this._loop=1,this._buffer.width!==this._animation.params.width&&(this._buffer.width=this._animation.params.width),this._buffer.height!==this._maxHeight&&(this._buffer.height=this._maxHeight),requestAnimationFrame(this._doAnimation.bind(this))):(this._isAnimating=!1,typeof this._endOfQueueListener=="function"&&this._endOfQueueListener(this._id))}enqueueSingle(i,e){this._queue.push({params:this._animations[i],loop:typeof e=="number"?e:0})}enqueueSequence(i,e){for(let t=0;t<i.length;t++)this._queue.push({params:this._animations[i[t].key],loop:Math.max(1,i[t].nbLoop)});this._loopSequence=!!e}run(){this._processQueue()}stop(){this._isAnimating=!1,this._loopSequence=!1,this._queue=[]}get data(){return this._buffer.canvas}get context(){return this._buffer.context}get width(){return this._maxWidth}get height(){return this._maxHeight}isAnimating(){return this._isAnimating}setEndOfQueueListener(i){this._endOfQueueListener=i}}class y{static hexRGBToHexRGBA(i,e){if(e.match(/[0-9a-f][0-9a-f]/gi))return i+e;throw new TypeError("alpha must be an hex string between 00 and FF")}static hexColorToInt(i,e){return parseInt(i.replace(/^#/gi,e||""),16)}static rgba2abgr(i){const e=i.match(/.{2}/g);if(e===null)throw new TypeError("Invalid rgba string");return e[3]+e[2]+e[1]+e[0]}static hexToArray(i){return i.match(/.{2}/g)||[]}static loadImagesOrdered(i){const e=i.map(t=>fetch(t));return Promise.all(e).then(t=>Promise.all(t.map(s=>s.blob()))).then(t=>Promise.all(t.map(s=>createImageBitmap(s))))}static async loadImagesOrderedAsync(i){const e=i.map(t=>fetch(t));return await Promise.all(e).then(t=>Promise.all(t.map(s=>s.blob()))).then(t=>Promise.all(t.map(s=>createImageBitmap(s))))}}class U{constructor(i){a(this,"_adapter");a(this,"_device");a(this,"_shaderModule");a(this,"_name");a(this,"_initDone");this._name=i,this._initDone=!1}get name(){return this._name}}class I extends U{constructor(e,t,s){super(e);a(this,"_width");a(this,"_height");a(this,"_bufferByteLength");a(this,"renderFrame");this._width=t,this._height=s,this._bufferByteLength=t*s*4,this.renderFrame=this._doNothing}_doNothing(e){return new Promise(t=>{t(e)})}}class O extends I{constructor(i,e){super("ChangeAlphaRenderer",i,e)}init(){return new Promise(i=>{navigator.gpu.requestAdapter().then(e=>{this._adapter=e,e.requestDevice().then(t=>{var s;this._device=t,this._shaderModule=t.createShaderModule({code:`
                            struct UBO {
                                opacity: f32
                            }

                            struct Image {
                                rgba: array<u32>
                            }

                            fn f2u(f: f32) -> u32 {
                                return u32(ceil(f));
                            }

                            @group(0) @binding(0) var<storage,read> inputPixels: Image;
                            @group(0) @binding(1) var<storage,read_write> outputPixels: Image;
                            @group(0) @binding(2) var<uniform> uniforms : UBO;

                            @compute
                            @workgroup_size(1)
                            fn main (@builtin(global_invocation_id) global_id: vec3<u32>) {
                                let index : u32 = global_id.x + global_id.y * ${this._width}u;
                                let pixelColor : u32 = inputPixels.rgba[index];
                                let opacity : f32 = uniforms.opacity;

                                
                                var a : u32 = (pixelColor >> 24u) & 255u;
                                let b : u32 = (pixelColor >> 16u) & 255u;
                                let g : u32 = (pixelColor >> 8u) & 255u;
                                let r : u32 = (pixelColor & 255u);

                                var aa = f2u(floor(f32(a) * opacity));

                                // Hack : Todo find why floor not working (0 * anything) should give 0
                                if (opacity == 0f) {
                                    aa = 0u;
                                }

                                outputPixels.rgba[index] = (aa << 24u) | (b << 16u) | (g << 8u) | r;
                            }
                        `}),console.log("ChangeAlphaRenderer:init()"),(s=this._shaderModule.getCompilationInfo())==null||s.then(r=>{r.messages.length>0&&console.warn("ChangeAlphaRenderer:compilationInfo() ",r.messages)}),this.renderFrame=this._doRendering,i()})})})}_doRendering(i,e){const t=new m({opacity:1}).merge(e),s=this._device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),r=this._device.createBuffer({mappedAtCreation:!0,size:this._bufferByteLength,usage:GPUBufferUsage.STORAGE}),n=this._device.createBuffer({size:this._bufferByteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),o=this._device.createBuffer({size:this._bufferByteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),h=this._device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),d=this._device.createBindGroup({layout:h,entries:[{binding:0,resource:{buffer:r}},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:s}}]}),f=this._device.createComputePipeline({layout:this._device.createPipelineLayout({bindGroupLayouts:[h]}),compute:{module:this._shaderModule,entryPoint:"main"}});return new Promise(g=>{new Uint8Array(r.getMappedRange()).set(new Uint8Array(i.data)),r.unmap();const p=[t.get("opacity")],c=new Float32Array(p);this._device.queue.writeBuffer(s,0,c.buffer);const l=this._device.createCommandEncoder(),_=l.beginComputePass();_.setPipeline(f),_.setBindGroup(0,d),_.dispatchWorkgroups(this._width,this._height),_.end(),l.copyBufferToBuffer(n,0,o,0,this._bufferByteLength),this._device.queue.submit([l.finish()]),o.mapAsync(GPUMapMode.READ).then(()=>{const b=new Uint8Array(o.getMappedRange()),w=new ImageData(new Uint8ClampedArray(b),this._width,this._height);g(w)})})}}class G extends U{constructor(e,t,s,r,n,o,h,d,f){super("DmdRenderer");a(this,"_dmdWidth");a(this,"_dmdHeight");a(this,"_screenWidth");a(this,"_screenHeight");a(this,"_dotSpace");a(this,"_pixelSize");a(this,"_dotShape");a(this,"_dmdBufferByteLength");a(this,"_screenBufferByteLength");a(this,"_bgBrightness");a(this,"_bgColor");a(this,"_brightness");a(this,"_bgHSP");a(this,"renderFrame");this._dmdWidth=e,this._dmdHeight=t,this._screenWidth=s,this._screenHeight=r,this._pixelSize=n,this._dotSpace=o,this._dotShape=h,this._dmdBufferByteLength=e*t*4,this._screenBufferByteLength=s*r*4,this.renderFrame=this._doNothing,this._bgBrightness=14,this._bgColor=4279176975,this._brightness=1,typeof d=="number"&&(this._bgBrightness=d,this._bgColor=parseInt("FF"+this._int2Hex(d)+this._int2Hex(d)+this._int2Hex(d),16)),typeof d=="number"&&this.setBrightness(f);const g=this._bgBrightness*this._bgBrightness;this._bgHSP=Math.sqrt(.299*g+.587*g+.114*g)}_int2Hex(e){let t=e.toString(16);return t.length<2&&(t="0"+t),t}init(){return new Promise(e=>{navigator.gpu.requestAdapter().then(t=>{this._adapter=t,t.requestDevice().then(s=>{var r;this._device=s,this._shaderModule=s.createShaderModule({code:`
                            struct UBO {
                                brightness: f32
                            }

                            struct Image {
                                rgba: array<u32>
                            }

                            fn f2i(f: f32) -> u32 {
                                return u32(ceil(f));
                            }

                            fn u2f(u: u32) -> f32 {
                                return f32(u);
                            }

                            @group(0) @binding(0) var<storage,read> inputPixels: Image;
                            @group(0) @binding(1) var<storage,read_write> outputPixels: Image;
                            @group(0) @binding(2) var<uniform> uniforms : UBO;

                            @compute
                            @workgroup_size(1)
                            fn main (@builtin(global_invocation_id) global_id: vec3<u32>) {
                                var bgBrightness : u32 = ${this._bgBrightness}u;
                                var index : u32 = global_id.x + global_id.y *  ${this._dmdWidth}u;
                                var pixel : u32 = inputPixels.rgba[index];
                                var brightness : f32 = uniforms.brightness;
                                var br = 0u;
                                var bg = 0u;
                                var bb = 0u;
                                
                                let a : u32 = (pixel >> 24u) & 255u;
                                let b : u32 = (pixel >> 16u) & 255u;
                                let g : u32 = (pixel >> 8u) & 255u;
                                let r : u32 = (pixel & 255u);

                                // If component is above darkest color then apply brightness limiter
                                if (r >= bgBrightness) {
                                    br = bgBrightness + f2i(f32(r - bgBrightness) * brightness);
                                }

                                // If component is above darkest color then apply brightness limiter
                                if (g >= bgBrightness) {
                                    bg = bgBrightness + f2i(f32(g - bgBrightness) * brightness);
                                }

                                // If component is above darkest color then apply brightness limiter
                                if (b >= bgBrightness) {
                                    bb = bgBrightness + f2i(f32(b - bgBrightness) * brightness);
                                }

                                // Recreate pixel color but force alpha to 255
                                pixel = (255u << 24u) | (bb << 16u) | (bg << 8u) | br;

                                var t : u32 = r + g + b;
                                var hsp : f32 =  sqrt(.299f * u2f(r) * u2f(r) + .587f * u2f(g) * u2f(g) + .114 * u2f(b) * u2f(b));
                
                                // Pixels that are too dark will be hacked to give the 'off' dot look of the DMD
                                //if (t < bgBrightness*3u) {
                                if (hsp - 8f < ${this._bgHSP}f) {
                                    pixel = ${this._bgColor}u;
                                    //pixel = 4294901760u;
                                }
                
                                // First byte index of the output dot
                                var resizedPixelIndex : u32 = (global_id.x * ${this._pixelSize}u)  + (global_id.x * ${this._dotSpace}u) + (global_id.y * ${this._screenWidth}u * (${this._pixelSize}u + ${this._dotSpace}u));
                
                                for ( var row: u32 = 0u ; row < ${this._pixelSize}u; row = row + 1u ) {
                                    for ( var col: u32 = 0u ; col < ${this._pixelSize}u; col = col + 1u ) {
                                        outputPixels.rgba[resizedPixelIndex] = pixel;
                                        resizedPixelIndex = resizedPixelIndex + 1u;
                                    }
                                    resizedPixelIndex = resizedPixelIndex + ${this._screenWidth}u - ${this._pixelSize}u;
                                }
                            }
                        `}),console.log("GPURenderer:init()"),(r=this._shaderModule.getCompilationInfo())==null||r.then(n=>{n.messages.length>0&&console.warn("GPURenderer:compilationInfo()",n.messages)}),this.renderFrame=this._doRendering,e()})})})}_doNothing(e){return console.log("Init not done cannot apply filter"),new Promise(t=>{t(e)})}_doRendering(e){const t=this._device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=this._device.createBuffer({mappedAtCreation:!0,size:this._dmdBufferByteLength,usage:GPUBufferUsage.STORAGE}),r=this._device.createBuffer({size:this._screenBufferByteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),n=this._device.createBuffer({size:this._screenBufferByteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),o=this._device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),h=this._device.createBindGroup({layout:o,entries:[{binding:0,resource:{buffer:s}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:t}}]}),d=this._device.createComputePipeline({layout:this._device.createPipelineLayout({bindGroupLayouts:[o]}),compute:{module:this._shaderModule,entryPoint:"main"}});return new Promise(f=>{new Uint8Array(s.getMappedRange()).set(new Uint8Array(e.data)),s.unmap();const g=[this._brightness],p=new Float32Array(g);this._device.queue.writeBuffer(t,0,p.buffer);const c=this._device.createCommandEncoder(),l=c.beginComputePass();l.setPipeline(d),l.setBindGroup(0,h),l.dispatchWorkgroups(this._dmdWidth,this._dmdHeight),l.end(),c.copyBufferToBuffer(r,0,n,0,this._screenBufferByteLength),this._device.queue.submit([c.finish()]),n.mapAsync(GPUMapMode.READ).then(()=>{const _=new Uint8Array(n.getMappedRange()),b=new ImageData(new Uint8ClampedArray(_),this._screenWidth,this._screenHeight);f(b)})})}setBrightness(e){const t=Math.max(0,Math.min(e,1));this._brightness=Math.round(t*1e3)/1e3}get brightness(){return this._brightness}}class T extends I{constructor(e,t,s,r){super("NoiseEffectRenderer",e,t);a(this,"_noises");a(this,"_startTime");a(this,"_frameDuration");a(this,"_nbFrames");a(this,"_tmpBuffer");if(this._nbFrames=r.length,this._frameDuration=s/this._nbFrames,this._noises=[],!Array.isArray(r))throw new TypeError("An array of images filename is expected as third argument");this._tmpBuffer=new B(e,t,!0);const n=r.map(o=>fetch(o));Promise.all(n).then(o=>Promise.all(o.map(h=>h.blob()))).then(o=>Promise.all(o.map(h=>createImageBitmap(h)))).then(o=>Promise.all(o.map(h=>this._getImageData(h)))).then(o=>{this._noises=o,console.log("Noises images loaded")})}async _loadNoise(e){const t=await fetch(e);if(t.ok)return await t.blob();throw new Error(`HTTP error! status: ${t.status}`)}init(){return new Promise(e=>{navigator.gpu.requestAdapter().then(t=>{this._adapter=t,t.requestDevice().then(s=>{var r;this._device=s,this._shaderModule=s.createShaderModule({code:`
                            struct Image {
                                rgba: array<u32>
                            }
                            @group(0) @binding(0) var<storage,read> noisePixels: Image;
                            @group(0) @binding(1) var<storage,read> inputPixels: Image;
                            @group(0) @binding(2) var<storage,read_write> outputPixels: Image;

                            @compute
                            @workgroup_size(1)
                            fn main (@builtin(global_invocation_id) global_id: vec3<u32>) {
                                let index : u32 = global_id.x + global_id.y * ${this._width}u;

                                var pixel : u32 = inputPixels.rgba[index];
                                var noise : u32 = noisePixels.rgba[index];
                                
                                let a : u32 = (pixel >> 24u) & 255u;
                                let r : u32 = (pixel >> 16u) & 255u;
                                let g : u32 = (pixel >> 8u) & 255u;
                                let b : u32 = (pixel & 255u);
                                //pixel = a << 24u | r << 16u | g << 8u | b;
               
                                if ( r > 200u && g > 200u && b > 200u ) {
                                //if ( pixel == 4294967295u ) {

                                    let na : u32 = (noise >> 24u) & 255u;
                                    let nr : u32 = (noise >> 16u) & 255u;
                                    let ng : u32 = (noise >> 8u) & 255u;
                                    let nb : u32 = (noise & 255u);
    
                                    // if finding a dark pixel on the noise buffer for this index
                                    // then alter the current pixel color (white-> blue)
                                    if ( nr < 200u && ng < 200u && nb < 200u) {
                                        pixel = pixel - 10100u;
                                    }
                                }

                                outputPixels.rgba[index] = pixel;
                                //outputPixels.rgba[index] = noise;
                            }
                        `}),console.log("ScoreEffectRenderer:init()"),(r=this._shaderModule.getCompilationInfo())==null||r.then(n=>{n.messages.length>0&&console.warn("ScoreEffectRenderer:compilationInfo() ",n.messages)}),this.renderFrame=this._doRendering,e()})})})}_doRendering(e){const t=this._device.createBuffer({mappedAtCreation:!0,size:this._bufferByteLength,usage:GPUBufferUsage.STORAGE}),s=this._device.createBuffer({mappedAtCreation:!0,size:this._bufferByteLength,usage:GPUBufferUsage.STORAGE}),r=this._device.createBuffer({size:this._bufferByteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),n=this._device.createBuffer({size:this._bufferByteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),o=this._device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),h=this._device.createBindGroup({layout:o,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:s}},{binding:2,resource:{buffer:r}}]}),d=this._device.createComputePipeline({layout:this._device.createPipelineLayout({bindGroupLayouts:[o]}),compute:{module:this._shaderModule,entryPoint:"main"}});return new Promise(f=>{const g=window.performance.now();this._startTime||(this._startTime=g);const p=g-this._startTime;let c=Math.floor(p/this._frameDuration);c>=this._nbFrames&&(this._startTime=null,c=0),new Uint8Array(t.getMappedRange()).set(new Uint8Array(this._noises[c])),t.unmap(),new Uint8Array(s.getMappedRange()).set(new Uint8Array(e.data)),s.unmap();const l=this._device.createCommandEncoder(),_=l.beginComputePass();_.setPipeline(d),_.setBindGroup(0,h),_.dispatchWorkgroups(this._width,this._height),_.end(),l.copyBufferToBuffer(r,0,n,0,this._bufferByteLength),this._device.queue.submit([l.finish()]),n.mapAsync(GPUMapMode.READ).then(()=>{const b=new Uint8Array(n.getMappedRange()),w=new ImageData(new Uint8ClampedArray(b),this._width,this._height);f(w)})})}_getImageData(e){return new Promise(t=>{this._tmpBuffer.context.drawImage(e,0,0),t(this._tmpBuffer.context.getImageData(0,0,this._width,this._height).data)})}}class E extends I{constructor(i,e){super("OutlineRenderer",i,e)}init(){return new Promise(i=>{navigator.gpu.requestAdapter().then(e=>{this._adapter=e,e.requestDevice().then(t=>{var s;this._device=t,this._shaderModule=t.createShaderModule({code:`
                            struct UBO {
                                innerColor: u32,
                                outerColor: u32,
                                lineWidth: u32
                            }
                            struct Image {
                                rgba: array<u32>
                            }

                            @group(0) @binding(0) var<storage,read> inputPixels: Image;
                            @group(0) @binding(1) var<storage,read_write> outputPixels: Image;
                            @group(0) @binding(2) var<uniform> uniforms : UBO;

                            @compute
                            @workgroup_size(1)
                            fn main (@builtin(global_invocation_id) global_id: vec3<u32>) {
                                let index : u32 = global_id.x + global_id.y * ${this._width}u;
                                let lineSize : u32 = ${this._width}u;

                                let pixelColor : u32 = inputPixels.rgba[index];
                                let innerColor : u32 = uniforms.innerColor;
                                let outerColor : u32 = uniforms.outerColor;
                                let lineWidth : u32 = uniforms.lineWidth;

                                
                                var a : u32 = (pixelColor >> 24u) & 255u;
                                let b : u32 = (pixelColor >> 16u) & 255u;
                                let g : u32 = (pixelColor >> 8u) & 255u;
                                let r : u32 = (pixelColor & 255u);
                                

                                // if inner color pixel found check pixels around
                                if (pixelColor != innerColor) {

                                    var innerColorFound = false;
                                    
                                    if (global_id.x > 0u && global_id.x < ${this._width-1}u && global_id.y > 0u && global_id.y < ${this._height-1}u) {
                                        let topPixel = index - lineSize * lineWidth;
                                        let bottomPixel = index + lineSize * lineWidth;
                                        let leftPixel = index - lineWidth;
                                        let rightPixel = index + lineWidth;
                                        let topLeftPixel = topPixel - lineWidth;
                                        let topRightPixel = topPixel + lineWidth;
                                        let bottomLeftPixel = bottomPixel - lineWidth;
                                        let bottomRightPixel = bottomPixel + lineWidth;

                                        if (
                                            inputPixels.rgba[topPixel] == innerColor ||
                                            inputPixels.rgba[rightPixel] == innerColor ||
                                            inputPixels.rgba[bottomPixel] == innerColor ||
                                            inputPixels.rgba[leftPixel] == innerColor ||
                                            inputPixels.rgba[topLeftPixel] == innerColor ||
                                            inputPixels.rgba[topRightPixel] == innerColor ||
                                            inputPixels.rgba[bottomLeftPixel] == innerColor ||
                                            inputPixels.rgba[bottomRightPixel] == innerColor
                                        ) {
                                            innerColorFound = true;
                                        }
                                    }


                                    if (innerColorFound) {
                                        outputPixels.rgba[index] = outerColor;
                                    } else {
                                        outputPixels.rgba[index] = pixelColor;
                                        //outputPixels.rgba[index] = 4294967040u;
                                    }

                                } else {
                                    outputPixels.rgba[index] = pixelColor;
                                }

                                //outputPixels.rgba[index] = 4278190335u;
                            }
                        `}),console.log("OutlineRenderer:init()"),(s=this._shaderModule.getCompilationInfo())==null||s.then(r=>{r.messages.length>0&&console.warn("OutlineRenderer:compilationInfo() ",r.messages)}),this.renderFrame=this._doRendering,i()})})})}_doRendering(i,e){const t=this._device.createBuffer({size:12,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=this._device.createBuffer({mappedAtCreation:!0,size:this._bufferByteLength,usage:GPUBufferUsage.STORAGE}),r=this._device.createBuffer({size:this._bufferByteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),n=this._device.createBuffer({size:this._bufferByteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),o=this._device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),h=this._device.createBindGroup({layout:o,entries:[{binding:0,resource:{buffer:s}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:t}}]}),d=this._device.createComputePipeline({layout:this._device.createPipelineLayout({bindGroupLayouts:[o]}),compute:{module:this._shaderModule,entryPoint:"main"}});return new Promise(f=>{new Uint8Array(s.getMappedRange()).set(new Uint8Array(i.data)),s.unmap();const g=[y.hexColorToInt(y.rgba2abgr(e.get("innerColor"))),y.hexColorToInt(y.rgba2abgr(e.get("outerColor"))),e.get("width")],p=new Int32Array(g);this._device.queue.writeBuffer(t,0,p.buffer);const c=this._device.createCommandEncoder(),l=c.beginComputePass();l.setPipeline(d),l.setBindGroup(0,h),l.dispatchWorkgroups(this._width,this._height),l.end(),c.copyBufferToBuffer(r,0,n,0,this._bufferByteLength),this._device.queue.submit([c.finish()]),n.mapAsync(GPUMapMode.READ).then(()=>{const _=new Uint8Array(n.getMappedRange()),b=new ImageData(new Uint8ClampedArray(_),this._width,this._height);f(b)})})}}class M extends I{constructor(i,e){super("RemoveAliasingRenderer",i,e)}init(){return new Promise(i=>{navigator.gpu.requestAdapter().then(e=>{this._adapter=e,e.requestDevice().then(t=>{var s;this._device=t,this._shaderModule=t.createShaderModule({code:`
                            struct UBO {
                                treshold : u32,
                                baseColor : u32
                            }
                            struct Image {
                                rgba: array<u32>
                            }

                            @group(0) @binding(0) var<storage,read> inputPixels: Image;
                            @group(0) @binding(1) var<storage,read_write> outputPixels: Image;
                            @group(0) @binding(2) var<uniform> uniforms : UBO;

                            @compute
                            @workgroup_size(1)
                            fn main (@builtin(global_invocation_id) global_id: vec3<u32>) {
                                let lineSize : u32 = ${this._width}u;
                                let lineWidth : u32 = 1u;

                                let index : u32 = global_id.x + global_id.y * lineSize;
                                var pixelColor : u32 = inputPixels.rgba[index];
                                
                                let a : u32 = (pixelColor >> 24u) & 255u;
                                let b : u32 = (pixelColor >> 16u) & 255u;
                                let g : u32 = (pixelColor >> 8u) & 255u;
                                let r : u32 = (pixelColor & 255u);

                                outputPixels.rgba[index] = pixelColor;

                                //let innerColor: u32 =  255u << 24u | a << 16u | g << 8u | r;
                                //let innerColor: u32 = 255u << 24u | 0u << 16u | 0u << 8u | 255u;
                                //let innerColor: u32 = 255u << 24u | 255u << 16u | 255u << 8u | 255u;
                                let innerColor = uniforms.baseColor;

                                if (a > 0u && pixelColor != innerColor) {

                                    var innerColorFound = false;

                                    if (global_id.x > 0u && global_id.x < ${this._width-1}u && global_id.y > 0u && global_id.y < ${this._height-1}u) {

                                        //outputPixels.rgba[index] = 255u << 24u | 255u << 16u | 255u << 8u | 0u;

                                        let topPixel = index - lineSize * lineWidth;
                                        let bottomPixel = index + lineSize * lineWidth;
                                        let leftPixel = index - lineWidth;
                                        let rightPixel = index + lineWidth;
                                        let topLeftPixel = topPixel - lineWidth;
                                        let topRightPixel = topPixel + lineWidth;
                                        let bottomLeftPixel = bottomPixel - lineWidth;
                                        let bottomRightPixel = bottomPixel + lineWidth;

                                        if (
                                            inputPixels.rgba[topPixel] == innerColor ||
                                            inputPixels.rgba[rightPixel] == innerColor ||
                                            inputPixels.rgba[bottomPixel] == innerColor ||
                                            inputPixels.rgba[leftPixel] == innerColor ||
                                            inputPixels.rgba[topLeftPixel] == innerColor ||
                                            inputPixels.rgba[topRightPixel] == innerColor ||
                                            inputPixels.rgba[bottomLeftPixel] == innerColor ||
                                            inputPixels.rgba[bottomRightPixel] == innerColor
                                        ) {
                                            innerColorFound = true;
                                        }
                                    }


                                    if (innerColorFound && a >= uniforms.treshold && a < 255u) {
                                        outputPixels.rgba[index] = (255u << 24u) | (b << 16u) | (g << 8u) | r;
                                    } else {
                                        outputPixels.rgba[index] = (0u << 24u) | (b << 16u) | (g << 8u) | r;
                                    }

                                }
                                // else {
                                    //outputPixels.rgba[index] = 200u << 24u | 0u << 16u | 0u << 8u | 0u;
                               // }

                               //outputPixels.rgba[index] = 255u << 24u | 255u << 16u | 255u << 8u | 255u;
             
                            }
                        `}),console.log("RemoveAliasingRenderer:init()"),(s=this._shaderModule.getCompilationInfo())==null||s.then(r=>{r.messages.length>0&&console.warn("RemoveAliasingRenderer:compilationInfo() ",r.messages)}),this.renderFrame=this._doRendering,i()})})})}_doRendering(i,e){const t=new m({treshold:0,baseColor:"FFFFFFFF"}).merge(e),s=this._device.createBuffer({size:8,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),r=this._device.createBuffer({mappedAtCreation:!0,size:this._bufferByteLength,usage:GPUBufferUsage.STORAGE}),n=this._device.createBuffer({size:this._bufferByteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),o=this._device.createBuffer({size:this._bufferByteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),h=this._device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),d=this._device.createBindGroup({layout:h,entries:[{binding:0,resource:{buffer:r}},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:s}}]}),f=this._device.createComputePipeline({layout:this._device.createPipelineLayout({bindGroupLayouts:[h]}),compute:{module:this._shaderModule,entryPoint:"main"}});return new Promise(g=>{new Uint8Array(r.getMappedRange()).set(new Uint8Array(i.data)),r.unmap();const p=[t.get("treshold"),y.hexColorToInt(y.rgba2abgr(t.get("baseColor")))],c=new Int32Array(p);this._device.queue.writeBuffer(s,0,c.buffer);const l=this._device.createCommandEncoder(),_=l.beginComputePass();_.setPipeline(f),_.setBindGroup(0,d),_.dispatchWorkgroups(this._width,this._height),_.end(),l.copyBufferToBuffer(n,0,o,0,this._bufferByteLength),this._device.queue.submit([l.finish()]),o.mapAsync(GPUMapMode.READ).then(()=>{const b=new Uint8Array(o.getMappedRange()),w=new ImageData(new Uint8ClampedArray(b),this._width,this._height);g(w)})})}}var x;(function(u){u[u.Image=0]="Image",u[u.Canvas=1]="Canvas",u[u.Text=2]="Text",u[u.Video=3]="Video",u[u.Animation=4]="Animation",u[u.Sprites=5]="Sprites"})(x||(x={}));class F{constructor(i,e,t,s,r,n,o,h){a(this,"_contentBuffer");a(this,"_options");a(this,"_id");a(this,"_loaded",!1);a(this,"_outputBuffer");a(this,"_layerType");a(this,"_renderNextFrame");a(this,"_loadedListener");a(this,"_updatedListener");a(this,"_availableRenderers");a(this,"_defaultRenderQueue");a(this,"_renderQueue");this._layerType=e,this._id=i,this._contentBuffer=new B(t,s,!0),this._outputBuffer=new B(t,s),this._loadedListener=o,this._updatedListener=h,this._defaultRenderQueue=[],this._renderQueue=[],this._availableRenderers=Object.assign({opacity:new O(t,s)},n),this._options=new m({visible:!0,groups:["default"],opacity:1,renderers:[]}).merge(r),this._renderNextFrame=function(){console.log(`Layer [${this._id}] : Rendering ended`)};const d=[];if(Object.keys(this._availableRenderers).forEach(f=>{d.push(this._availableRenderers[f].init())}),Promise.all(d).then(()=>{console.log(`Layer[${i}] : Renderers init done`)}),this._options.get("renderers").length>0)for(let f=0;f<this._options.get("renderers").length;f++){const g=this._options.get("renderers")[f];typeof this._availableRenderers[g]<"u"?this._defaultRenderQueue.push({id:g,instance:this._availableRenderers[g]}):console.log(`Renderer "${g}" is not in the list of available renderers`)}}_requestAnimationFrame(){requestAnimationFrame(this._renderFrame.bind(this))}_renderFrame(){this._renderQueue=[...this._defaultRenderQueue],this._options.get("opacity")<1&&this._renderQueue.push({id:"opacity",instance:this._availableRenderers.opacity,params:new m({opacity:parseFloat(this._options.get("opacity"))})});const i=this._contentBuffer.context.getImageData(0,0,this._outputBuffer.width,this._outputBuffer.height);this._processRenderQueue(i)}_processRenderQueue(i){if(this._renderQueue.length){const e=this._renderQueue.shift();e==null||e.instance.renderFrame(i,e.params).then(t=>{this._processRenderQueue(t)})}else this._outputBuffer.clear(),createImageBitmap(i).then(e=>{this._outputBuffer.context.drawImage(e,0,0),this._renderNextFrame()})}_layerLoaded(i=!1){if(this._loaded=!0,console.log(`Layer [${this._id}] : Loaded`),this._defaultRenderQueue.length===0&&this._options.get("opacity")===1){const e=this._contentBuffer.context.getImageData(0,0,this._outputBuffer.width,this._outputBuffer.height);this._outputBuffer.clear(),createImageBitmap(e).then(t=>{this._outputBuffer.context.drawImage(t,0,0)})}this.isVisible()&&(this.haveRenderer()||i)&&(this._renderNextFrame=this._requestAnimationFrame,this._requestAnimationFrame()),typeof this._loadedListener=="function"&&this._loadedListener(this)}_setAntialiasing(i){this._outputBuffer.context.imageSmoothingEnabled=i}_getRendererInstance(i){if(typeof this._availableRenderers[i]<"u")return this._availableRenderers[i];throw new Error("This renderer is not available")}_logDebug(i){console.log(`Layer[${this.id}] : `+i)}_logWarning(i){console.warn(`Layer[${this.id}] : `+i)}_logError(i){console.error(`Layer[${this.id}] : `+i)}_layerUpdated(){console.log(`Layer [${this._id}] : Updated => ${this.haveRenderer()}`),this.haveRenderer()||this._renderFrame(),typeof this._updatedListener=="function"&&this._updatedListener(this)}_stopRendering(){this._renderNextFrame=function(){console.log(`Rendering stopped : ${this._id}`)}}_startRendering(){console.log(`Layer [${this._id}] : Start rendering`),this._renderNextFrame=this._requestAnimationFrame,this._requestAnimationFrame()}haveRenderer(){return this._defaultRenderQueue.length>0}setVisibility(i){i!==this.isVisible()&&(this._options.set("visible",i),i&&this.haveRenderer()?(this._renderNextFrame=this._requestAnimationFrame,this._requestAnimationFrame()):this._renderNextFrame=function(){console.log("End of rendering :"+this._id)})}toggleVisibility(){const i=this._options.get("visible");return this.setVisibility(!i),!i}isVisible(){return this._options.get("visible")}isLoaded(){return this._loaded}destroy(){this._renderNextFrame=function(){console.log(`Destroying layer : ${this._id}`)}}get id(){return this._id}get width(){return this._outputBuffer.width}get height(){return this._outputBuffer.height}get canvas(){return this._outputBuffer.canvas}get layerType(){return this._layerType}get groups(){return this._options.get("groups")||["default"]}get options(){return this._options}}class q extends F{constructor(e,t,s,r,n,o,h,d,f,g){const p=new m({loop:!1,autoplay:!1}).merge(r);super(e,x.Video,t,s,p,n,o,h);a(this,"_onPlayListener");a(this,"_onPauseListener");a(this,"_onStopListener");a(this,"__renderNextFrame");a(this,"_images");a(this,"_isPlaying");a(this,"_isPaused");a(this,"_loop");a(this,"_frameIndex");a(this,"_startTime");a(this,"_frameDuration");this._onPlayListener=d,this._onPauseListener=f,this._onStopListener=g,this._images=[],this._isPlaying=!1,this._isPaused=!1,this._frameIndex=0,this._loop=p.get("loop"),this.__renderNextFrame=function(){},setTimeout(this._layerLoaded.bind(this),1)}setAnimationData(e){this._images=e,this._onImagesLoaded()}_onImagesLoaded(){this._frameDuration=this._options.get("duration")/this._images.length,this._contentBuffer.context.drawImage(this._images[this._frameIndex],0,0,this.width,this.height),this._layerUpdated(),this._options.get("autoplay")&&this.play()}__renderFrame(e){const t=e,s=this._frameIndex;this._startTime||(this._startTime=t);const r=t-this._startTime;let n=Math.floor(r/this._frameDuration);if(!this._loop&&n>=this._images.length){this.stop();return}n>=this._images.length&&(this._startTime=null,n=0),this._frameIndex=n,n!==s&&this._drawImage(),this.__renderNextFrame()}_drawImage(){this._contentBuffer.clear(),this._contentBuffer.context.drawImage(this._images[this._frameIndex],0,0,this.width,this.height)}_requestRenderNextFrame(){requestAnimationFrame(this.__renderFrame.bind(this))}play(e){this.isLoaded()&&!this._isPlaying&&(typeof e<"u"?this._loop=!!e:this._isPaused||(this._loop=this._options.get("loop")),this._startTime=null,this._isPlaying=!0,this._isPaused=!1,this.__renderNextFrame=this._requestRenderNextFrame,this._requestRenderNextFrame(),this._startRendering(),typeof this._onPlayListener=="function"&&this._onPlayListener(this))}stop(){this._isPlaying&&(this._isPlaying=!1,this._isPaused=!1,this._frameIndex=0,this.__renderNextFrame=function(){},this._stopRendering(),typeof this._onStopListener=="function"&&this._onStopListener(this))}pause(){this._isPlaying&&(this._loop?(this._isPlaying=!1,this._isPaused=!0,this.__renderNextFrame=function(){},typeof this._onPauseListener=="function"&&this._onPauseListener(this)):(console.log("Only looping animation can be paused"),this.stop()))}resume(){this._isPaused?this.play():console.log("This video is not paused")}nextFrame(){let e=this._frameIndex+1;e>=this._images.length&&(e=0),this._frameIndex=e,requestAnimationFrame(this._drawImage.bind(this)),this._layerUpdated()}previousFrame(){let e=this._frameIndex-1;e<=0&&(e=this._images.length-1),this._frameIndex=e,requestAnimationFrame(this._drawImage.bind(this)),this._layerUpdated()}setVisibility(e){super.setVisibility(e),!e&&this._isPlaying?this.pause():e&&this._isPaused&&this.resume()}get isPlaying(){return this._isPlaying}get isPaused(){return this._isPaused}}class D extends F{constructor(i,e,t,s,r,n,o){super(i,x.Canvas,e,t,s,r,n,o),setTimeout(this._layerLoaded.bind(this),1)}drawBitmap(i,e){const t=new m({top:0,left:0,hOffset:0,vOffset:0,fit:!0,keepAspectRatio:!0}).merge(e),s=this._computeDimensions(t,i.width,i.height);this._contentBuffer.context.drawImage(i,s.left,s.top,s.width,s.height),this._layerUpdated()}_computeDimensions(i,e,t){let s=0,r=0,n=e,o=t;if(i.get("fit")===!0)if(i.get("keepAspectRatio")===!0){const h=e/t;if(h===1){const d=Math.min(this.width,this.height);n=d,o=d}else h>1?(n=this.width,o=Math.round(n*t/e)):(o=this.height,e=Math.round(o*e/t))}else n=this.width,o=this.height;else{const h=i.get("width")===void 0||i.get("height")===void 0,d=i.get("width")===void 0&&i.get("height")===void 0;if(typeof i.get("width")=="number")n=i.get("width");else if(typeof i.get("width")=="string"&&i.get("width").at(-1)==="%"){const f=parseInt(i.get("width").replace("%",""),10);n=Math.floor(f*this.width/100)}if(typeof i.get("height")=="number")o=i.get("height");else if(typeof i.get("height")=="string"&&i.get("height").at(-1)==="%"){const f=parseInt(i.get("height").replace("%",""),10);o=Math.floor(f*this.height/100)}i.get("keepAspectRatio")&&h&&!d&&(typeof i.get("width")>"u"?n=Math.round(i.get("height")*e/t):typeof i.get("height")>"u"&&(o=Math.round(i.get("width")*t/e)))}if(typeof i.get("left")=="string"&&i.get("left").at(-1)==="%"){const h=parseInt(i.get("left").replace("%",""),10);r=Math.round(h*this.width/100)}if(typeof i.get("top")=="string"&&i.get("top").at(-1)==="%"){const h=parseInt(i.get("top").replace("%",""),10);s=Math.round(h*this.height/100)}if(typeof i.get("hAlign")=="string")switch(i.get("hAlign")){case"left":r=0+i.get("hOffset");break;case"center":r=this.width/2-n/2+i.get("hOffset");break;case"right":r=this.width-n+i.get("hOffset");break;default:console.warn(`CanvasLaye[${this.id}].drawImage(): Incorrect value align:'${i.get("align")}'`)}if(typeof i.get("vAlign")=="string")switch(i.get("vAlign")){case"top":s=0+i.get("vOffset");break;case"middle":s=this.height/2-o/2+i.get("vOffset");break;case"bottom":s=this.height-o+i.get("vOffset");break;default:console.warn(`CanvasLayer[${this.id}].drawImage(): Incorrect value vAlign:'${i.get("vAlign")}'`)}return{top:s,left:r,width:n,height:o}}}class k extends F{constructor(e,t,s,r,n,o,h){const d=new m({loop:!1,autoplay:!1}).merge(r);super(e,x.Sprites,t,s,d,n,o,h);a(this,"_sprites");a(this,"_runningSprites");a(this,"__renderNextFrame");this._sprites={},this._runningSprites=0,this.__renderNextFrame=function(){},setTimeout(this._layerLoaded.bind(this),1)}__renderFrame(){this._contentBuffer.clear(),Object.keys(this._sprites).forEach(e=>{const t=this._sprites[e];t.visible&&this._contentBuffer.context.drawImage(t.sprite.data,t.x,t.y)}),this.__renderNextFrame()}_requestRenderNextFrame(){requestAnimationFrame(this.__renderFrame.bind(this))}createSprite(e,t,s,r,n,o,h){return new Promise((d,f)=>{if(typeof this._sprites[e]>"u")if(n.length){const g=new C(e,t,s,r);for(let p=0;p<n.length;p++)g.addAnimation(n[p].key,n[p].animationParams);this.addSprite(e,g,o,h),d(g)}else f(`No animations provided for sprite ${e}`);else f(`Sprite [${e}] already exists`)})}addSprite(e,t,s,r,n){let o=!0;if(typeof t=="object"&&t.constructor!==C)return console.error("Provided sprite is not a Sprite object"),!1;if(typeof this._sprites[e]<"u")return console.error("Already exists : "+e),!1;typeof n<"u"&&(o=!!n);let h=s||0,d=r||0;if(s.at(-1)==="%"){const f=parseFloat(s.replace("%",""));h=Math.floor(f*this.width/100)}else h=parseInt(s,10);if(r.at(-1)==="%"){const f=parseFloat(r.replace("%",""));d=Math.floor(f*this.height/100)}else d=parseInt(r,10);return this._sprites[e]={x:h,y:d,sprite:t,visible:o},t.setEndOfQueueListener(this._onQueueEnded.bind(this)),this._layerUpdated(),!0}_onQueueEnded(){this._runningSprites--,this._runningSprites<=0&&(this._runningSprites=0,this.__renderNextFrame=function(){},this._stopRendering())}setSpriteVisibility(e,t){typeof this._sprites[e]<"u"?this._sprites[e].visible=t:console.error(`Layer[${this.id}] : sprite [${e}] does not exist`)}run(e){typeof this._sprites[e]<"u"?(this._startRendering(),this._sprites[e].sprite.isAnimating()||(this._runningSprites++,this._sprites[e].sprite.run(),this._runningSprites===1&&(this.__renderNextFrame=this._requestRenderNextFrame,this._requestRenderNextFrame()))):console.error(`Layer[${this.id}] : sprite [${e}] does not exist`)}stop(e){typeof this._sprites[e]<"u"?this._sprites[e].sprite.isAnimating()&&(this._runningSprites--,this._sprites[e].sprite.stop()):console.error(`Layer[${this.id}] : sprite [${e}] does not exist`),this._runningSprites<=0&&(this._runningSprites=0,this.__renderNextFrame=function(){})}enqueueSequence(e,t,s){typeof this._sprites[e]<"u"?this._sprites[e].sprite.enqueueSequence(t,s):console.error(`Layer[${this.id}] : sprite [${e}] does not exist`)}}var v;(function(u){u.Blue="#21A6DF",u.Red="#FF0000",u.White="#FFFFFF",u.Black="#000000",u.Green="#00FF00",u.Yellow="#FFFF00"})(v||(v={}));var R;(function(u){u[u.Square=0]="Square",u[u.Circle=1]="Circle"})(R||(R={}));class N extends F{constructor(e,t,s,r,n,o,h){const d=new m({top:0,left:0,color:v.White,fontSize:"10",fontUnit:"%",fontFamily:"Arial",fontStyle:"normal",textBaseline:"top",hOffset:0,vOffset:0,strokeWidth:0,strokeColor:v.Black,adjustWidth:!1,outlineWidth:0,outlineColor:v.Black,antialiasing:!0}).merge(r),f=Object.assign({"no-antialiasing":new M(t,s),outline:new E(t,s)},n);super(e,x.Text,t,s,d,f,o,h);a(this,"_text");a(this,"_textBuffer");if(this._textBuffer=new B(this.width,this.height),this._text="",setTimeout(this._layerLoaded.bind(this),1),this._options.has("text")){if(typeof this._options.get("text")!="string")throw new TypeError("options.text is not a string");this._options.get("text")!==""&&(this._text=this._options.get("text"),this._drawText().then(()=>{setTimeout(this._layerUpdated.bind(this),1)}))}}_drawText(e){const t=new m(this._options).merge(e);return new Promise(s=>{this._textBuffer.context.imageSmoothingEnabled=t.get("antialiasing"),this._setAntialiasing(t.get("antialiasing")),t.get("outlineWidth")>0&&t.set("strokeWidth",0),this._textBuffer.clear();let r=t.get("left"),n=t.get("top"),o;this._textBuffer.context.textBaseline=t.get("textBaseline"),this._textBuffer.context.fillStyle=t.get("color");let h=t.get("fontSize"),d=t.get("fontUnit");if(d==="%"&&(d="px",h=h*this.height/80),t.get("adjustWidth")){let l=!1;for(;!l;)if(this._textBuffer.context.font=t.get("fontStyle")+" "+h+d+" "+t.get("fontFamily"),o=this._textBuffer.context.measureText(this._text),o.width>this.width-5){const _=t.get("fontSize");t.set("fontSize",_-1)}else l=!0}else this._textBuffer.context.font=t.get("fontStyle")+" "+h+d+" "+t.get("fontFamily"),o=this._textBuffer.context.measureText(this._text);const f=this._textBuffer.context.measureText("M").width;if(typeof t.get("left")=="string"&&t.get("left").at(-1)==="%"){const l=parseFloat(t.get("left").replace("%",""));r=Math.floor(l*this.width/100)}if(typeof t.get("top")=="string"&&t.get("top").at(-1)==="%"){const l=parseFloat(t.get("top").replace("%",""));n=Math.floor(l*this.height/100)}if(typeof t.get("hAlign")=="string")switch(t.get("hAlign")){case"left":r=0;break;case"center":r=this.width/2-o.width/2;break;case"right":r=this.width-o.width}if(typeof t.get("vAlign")=="string")switch(t.get("vAlign")){case"top":n=0;break;case"middle":n=this.height/2-f/2;break;case"bottom":n=this.height-f;break}let g=t.get("hOffset");const p=t.get("vOffset");if(typeof t.get("hOffset")=="string"&&t.get("hOffset").at(-1)==="%"){const l=parseFloat(t.get("hOffset").replace("%",""));g=Math.floor(l*this.width/100)}if(typeof t.get("vOffset")=="string"&&t.get("vOffset").at(-1)==="%"){const l=parseFloat(t.get("vOffset").replace("%",""));g=Math.floor(l*this.height/100)}r+=g,n+=p,t.get("strokeWidth")>0&&(this._textBuffer.context.strokeStyle=t.get("strokeColor"),this._textBuffer.context.lineWidth=t.get("strokeWidth"),this._textBuffer.context.strokeText(this._text,r,n)),this._textBuffer.context.fillText(this._text,r,n);const c=this._textBuffer.context.getImageData(0,0,this.width,this.height);t.get("outlineWidth")>0?this._options.get("antialiasing")?this._getRendererInstance("outline").renderFrame(c,new m({innerColor:y.hexRGBToHexRGBA(this._options.get("color").replace("#",""),"FF"),outerColor:y.hexRGBToHexRGBA(this._options.get("outlineColor").replace("#",""),"FF"),width:this._options.get("outlineWidth")})).then(l=>{createImageBitmap(l).then(_=>{this._contentBuffer.clear(),this._contentBuffer.context.drawImage(_,0,0),s()})}):this._getRendererInstance("no-antialiasing").renderFrame(c,new m({treshold:255,baseColor:y.hexRGBToHexRGBA(this._options.get("color").replace("#",""),"FF")})).then(l=>{this._getRendererInstance("outline").renderFrame(l,new m({innerColor:y.hexRGBToHexRGBA(this._options.get("color").replace("#",""),"FF"),outerColor:y.hexRGBToHexRGBA(this._options.get("outlineColor").replace("#",""),"FF"),width:this._options.get("outlineWidth")})).then(_=>{createImageBitmap(_).then(b=>{this._contentBuffer.clear(),this._contentBuffer.context.drawImage(b,0,0),s()})})}):this._options.get("antialiasing")?(this._contentBuffer.clear(),this._contentBuffer.context.drawImage(this._textBuffer.canvas,0,0),s()):this._getRendererInstance("no-antialiasing").renderFrame(c,new m({treshold:255,baseColor:y.hexRGBToHexRGBA(this._options.get("color").replace("#",""),"FF")})).then(l=>{createImageBitmap(l).then(_=>{this._contentBuffer.clear(),this._contentBuffer.context.fillRect(0,0,this.width,this.height),this._contentBuffer.context.drawImage(_,0,0),s()})})})}setText(e,t){if(typeof e!="string")throw new TypeError("text is not a string");typeof e<"u"&&e!==""&&e!==this._text&&(this._text=e,this._drawText(t).then(()=>{this._layerUpdated()}))}setVisibility(e){super.setVisibility(e)}}var P;(function(u){u[u.STOPPED=0]="STOPPED",u[u.PAUSED=1]="PAUSED",u[u.PLAYING=2]="PLAYING"})(P||(P={}));class W extends F{constructor(e,t,s,r,n,o,h,d,f,g){const p=new m({loop:!1,autoplay:!1,pauseOnHide:!0,stopOnHide:!1}).merge(r);super(e,x.Video,t,s,p,n,o,h);a(this,"_video");a(this,"_onPlayListener");a(this,"_onPauseListener");a(this,"_onStopListener");a(this,"__renderNextFrame");a(this,"_internalAction");a(this,"_state",P.STOPPED);this._onPlayListener=d,this._onPauseListener=f,this._onStopListener=g,this.__renderNextFrame=function(){},this._options.get("stopOnHide")===!0&&this._options.set("pauseOnHide",!1),this._options.get("autoplay")===!0&&this._options.get("visible")===!1&&(this._internalAction=!0),setTimeout(this._layerLoaded.bind(this),1)}_onVideoError(e){console.error(e)}_onVideoLoaded(){this._contentBuffer.context.drawImage(this._video,0,0,this._options.get("width"),this._options.get("height")),this._options.get("autoplay")&&this._options.get("visible")&&this.play(),this._layerUpdated()}_onVideoPlayed(){this.__renderNextFrame=this._requestRenderNextFrame,this._requestRenderNextFrame(),typeof this._onPlayListener=="function"&&this._onPlayListener(this)}_onVideoPaused(){this.__renderNextFrame=function(){console.log("End of video rendering")},this._stopRendering(),typeof this._onPauseListener=="function"&&this._onPauseListener(this)}__renderFrame(){this._contentBuffer.clear(),this._contentBuffer.context.drawImage(this._video,0,0,this._options.get("width"),this._options.get("height")),this.__renderNextFrame(this)}_requestRenderNextFrame(){requestAnimationFrame(this.__renderFrame.bind(this))}_play(){if(!this.isVisible){console.error(`Layer[${this.id}] is not visible`);return}if(this._state===P.PLAYING){this._logWarning("Video is already beeing played");return}this._state=P.PLAYING,this._internalAction=!1,this.__renderNextFrame=this._requestRenderNextFrame,this._requestRenderNextFrame(),this._video.play(),this._startRendering()}_pause(e=!1){if(this._video===void 0){this._logWarning("Video is not set");return}if(this._state!==P.PLAYING){this._logWarning("Video is not beeing played");return}this._internalAction=e,this._state=P.PAUSED,this._video.pause(),this.__renderNextFrame=function(){"End of video rendering"}}_stop(e=!1){if(this._video===void 0){this._logWarning("Video is not set");return}this._state!==P.PLAYING&&this._logWarning("Video was not beeing played"),this._internalAction=e,this._state=P.STOPPED,this._video.pause(),this._video.currentTime=0,this.__renderNextFrame=function(){"End of video rendering"}}setVisibility(e){e!==this.isVisible()&&(super.setVisibility(e),!e&&this._state===P.PLAYING&&(this._options.get("stopOnHide")||this._options.get("pausepOnHide"))&&(this._options.get("stopOnHide")?this._stop(!0):this._options.get("pauseOnHide")&&this._pause(!0)),e&&this._state!==P.PLAYING&&this._internalAction&&this._play())}setVideo(e){this._video=e,this._video.loop=this._options.get("loop"),this._video.addEventListener("play",this._onVideoPlayed.bind(this)),this._video.addEventListener("pause",this._onVideoPaused.bind(this)),this._onVideoLoaded()}loadVideo(e){this._video=document.createElement("video"),this._video.width=this._options.get("width")||this.width,this._video.height=this._options.get("height")||this.height,this._video.loop=this._options.get("loop")||!1,this._video.addEventListener("play",this._onVideoPlayed.bind(this)),this._video.addEventListener("pause",this._onVideoPaused.bind(this)),this._video.addEventListener("loadeddata",this._onVideoLoaded.bind(this)),this._video.addEventListener("error",this._onVideoError.bind(this)),this._video.src=e}play(){this._play()}pause(){this._pause()}stop(){this._stop()}isPlaying(){return this._state===P.PLAYING}}class ${constructor(i,e,t,s,r,n,o,h,d){a(this,"_outputCanvas");a(this,"_outputContext");a(this,"_xOffset");a(this,"_yOffset");a(this,"_layers");a(this,"_sortedLayers");a(this,"_outputWidth");a(this,"_outputHeight");a(this,"_frameBuffer");a(this,"_fpsBox");a(this,"_zIndex");a(this,"_renderer");a(this,"_isRunning");a(this,"_fps");a(this,"_lastRenderTime");a(this,"_layerRenderers");a(this,"_initDone");a(this,"_backgroundColor");a(this,"_renderNextFrame");a(this,"_renderFPS");a(this,"_minFPS");a(this,"_maxFPS");this._outputCanvas=i,this._outputContext=this._outputCanvas.getContext("2d"),this._xOffset=s,this._yOffset=r,this._outputWidth=Math.floor(this._outputCanvas.width/(e+t)),this._outputHeight=Math.floor(this._outputCanvas.height/(e+t)),this._frameBuffer=new B(this._outputWidth,this._outputHeight,!0),this._zIndex=1,this._layers={},this._sortedLayers=[],this._renderFPS=function(){},this._backgroundColor="rgba(14, 14, 14, 255)",this._isRunning=!1,this._renderNextFrame=function(){},this._fps=0,this._minFPS=9999,this._maxFPS=0,console.log(`Creating a ${this._outputWidth}x${this._outputHeight} DMD on a ${this._outputCanvas.width}x${this._outputCanvas.height} canvas`),this._renderer=new G(this._outputWidth,this._outputHeight,this._outputCanvas.width,this._outputCanvas.height,e,t,n||R.Circle,o,h),this._layerRenderers={},this._initDone=!1,d&&(this._fpsBox=document.createElement("div"),this._fpsBox.style.position="absolute",this._fpsBox.style.right="0",this._fpsBox.style.top="0",this._fpsBox.style.zIndex="99999",this._fpsBox.style.color="red",this._fpsBox.style.background="rgba(255,255,255,0.5)",this._fpsBox.style.padding="5px",this._fpsBox.style.minWidth="40px",this._fpsBox.style.textAlign="center",document.body.appendChild(this._fpsBox),this._renderFPS=this.__renderFPS),this.reset()}init(){return new Promise(i=>{this._renderer.init().then(()=>{this._initDone=!0,i()})})}run(){if(!this._initDone)throw new Error("call Dmd.init() first");this._isRunning=!0,this._lastRenderTime=window.performance.now(),this._renderNextFrame=this.requestNextFrame,this._renderNextFrame()}stop(){this._isRunning=!1,this._renderNextFrame=function(){console.log("Dmd render stopped")}}renderDMD(){this._frameBuffer.context.fillStyle=this._backgroundColor,this._frameBuffer.context.fillRect(0,0,this._outputWidth,this._outputHeight),this._sortedLayers.forEach(e=>{const t=this._layers[e.id];t.isVisible()&&t.isLoaded()&&this._frameBuffer.context.drawImage(t.canvas,e.left,e.top)});const i=this._frameBuffer.context.getImageData(0,0,this._frameBuffer.width,this._frameBuffer.height);this._renderer.renderFrame(i).then(e=>{createImageBitmap(e).then(t=>{this._outputContext.clearRect(0,0,this._outputCanvas.width,this._outputCanvas.height),this._outputContext.drawImage(t,0,0);const s=performance.now(),r=s-this._lastRenderTime;this._lastRenderTime=s,this._fps=Math.floor(Math.round(1e3/r*100)/100),this._fps<this._minFPS&&(this._minFPS=this._fps),this._fps>this._maxFPS&&(this._maxFPS=this._fps),this._renderFPS(),this._renderNextFrame()})})}__renderFPS(){this._fpsBox.innerHTML=`${this._minFPS} / ${this._fps} / ${this._maxFPS}`}requestNextFrame(){requestAnimationFrame(this.renderDMD.bind(this))}sortLayers(){this._sortedLayers=this._sortedLayers.sort((i,e)=>i.zIndex>e.zIndex?1:-1)}fadeOut(i){const e=window.performance.now(),t=this._renderer.brightness;return new Promise(s=>{const r=this._renderer,n=function(){const o=window.performance.now()-e,h=t-A.easeOutSine(o,0,t,i);r.setBrightness(h),r.brightness<=0||o>i?(r.setBrightness(0),s()):setTimeout(n,1)};n()})}fadeIn(i){const e=window.performance.now(),t=this._renderer.brightness;return new Promise(s=>{const r=this._renderer,n=function(){const o=window.performance.now()-e,h=A.easeOutSine(o,t,1,i);r.setBrightness(h),r.brightness>=1||o>i?(r.setBrightness(1),s()):setTimeout(n,1)};n()})}setBrightness(i){this._renderer.setBrightness(i)}addCanvasLayer(i,e,t,s,r,n){return this._addLayer(x.Canvas,i,e,t,s,r,n)}addVideoLayer(i,e,t,s,r,n,o,h){return this._addLayer(x.Video,i,e,t,s,r,n,o,h)}addAnimationLayer(i,e,t,s,r,n,o,h,d){return this._addLayer(x.Animation,i,e,t,s,r,n,o,h,d)}addSpritesLayer(i,e,t,s,r,n){return this._addLayer(x.Sprites,i,e,t,s,r,n)}addTextLayer(i,e,t,s,r,n){return this._addLayer(x.Text,i,e,t,s,r,n)}removeLayer(i){typeof this._layers[i]<"u"?(this._layers[i].destroy(),delete this._layers[i],this._sortedLayers=this._sortedLayers.filter(e=>e.id!==i),console.log(`Removing layer : ${i}`)):console.log("This layer does not exist")}setLayerVisibility(i,e){typeof this._layers[i]<"u"&&this._layers[i].setVisibility(!!e)}setLayerGroupVisibility(i,e){Object.keys(this._layers).forEach(t=>{this._layers[t].groups.includes(i)&&this._layers[t].setVisibility(!!e)})}addRenderer(i,e){if(this._isRunning)throw new Error("Renderers must be added before calling Dmd.init()");if(typeof this._layerRenderers[i]>"u")if(typeof e=="object"&&typeof e.renderFrame=="function")this._layerRenderers[i]=e;else throw new Error("Renderer object might not be a Renderer class");else throw new Error(`A renderer with this id[${i}] already exists`)}reset(){this._layers={},this._sortedLayers=[]}debug(){console.log(this._layers),console.log(this._sortedLayers)}getLayer(i){return typeof this._layers[i]<"u"?this._layers[i]:null}get brightness(){return this._renderer.brightness}get canvas(){return this._outputCanvas}get context(){return this._outputContext}get width(){return this._outputWidth}get height(){return this._outputHeight}get screenWidth(){return this._outputCanvas.width}get screenHeight(){return this._outputCanvas.height}get fps(){return this._fps}_addLayer(i,e,t,s,r,n,o,h,d,f){if(typeof this._layers[e]<"u")throw new Error(`Layer [${e}] already exists`);const g=new m(s),p=t.width||this._outputWidth,c=t.height||this._outputHeight;let l=t.top||0,_=t.left||0;if(typeof t.hAlign=="string")switch(t.hAlign){case"left":_=t.hOffset||0;break;case"center":_=(this._outputWidth-p)/2+(t.hOffset||0)-1;break;case"right":_=this._outputWidth-p+(t.hOffset||0)-1}if(typeof t.vAlign=="string")switch(t.vAlign){case"top":l=t.vOffset||0;break;case"middle":l=(this._outputHeight-c)/2+(t.vOffset||0)-1;break;case"bottom":l=this._outputHeight-c+(t.vOffset||0)-1}let b;switch(i){case x.Canvas:b=new D(e,p,c,g,r,n,o);break;case x.Video:b=new W(e,p,c,g,r,n,o,h,d);break;case x.Animation:b=new q(e,p,c,g,r,n,o,h,d,f);break;case x.Sprites:b=new k(e,p,c,g,r,n,o);break;case x.Text:b=new N(e,p,c,g,r,n,o);break;default:throw new TypeError(`Invalid layer type : ${i}`)}this._layers[e]=b;let w=this._zIndex;return g.has("zIndex")?w=g.get("zIndex"):this._zIndex++,this._sortedLayers.push({id:e,zIndex:w,top:l,left:_}),this.sortLayers(),b}}document.addEventListener("DOMContentLoaded",function(){if("gpu"in navigator){const u=document.getElementById("output"),i=new $(u,2,1,1,1,R.Square,14,1,!0),e=[];for(let t=0;t<6;t++)e.push(`${document.baseURI}/images/noises/noise-${t}.png`);i.init().then(()=>{i.run(),i.addCanvasLayer("bg",{},{},{},s=>{const r=document.baseURI+"/images/boss-mode-bg.png";fetch(r).then(n=>n.blob()).then(n=>createImageBitmap(n)).then(n=>{s.drawBitmap(n)})}),i.addAnimationLayer("animation",{width:426,height:90,top:20,left:0},new m({duration:800,autoplay:!0,loop:!0}),{},s=>{const r=[document.baseURI+"/images/animation/0.webp",document.baseURI+"/images/animation/1.webp",document.baseURI+"/images/animation/2.webp",document.baseURI+"/images/animation/3.webp",document.baseURI+"/images/animation/4.webp",document.baseURI+"/images/animation/5.webp",document.baseURI+"/images/animation/6.webp",document.baseURI+"/images/animation/7.webp",document.baseURI+"/images/animation/8.webp",document.baseURI+"/images/animation/9.webp",document.baseURI+"/images/animation/10.webp",document.baseURI+"/images/animation/11.webp",document.baseURI+"/images/animation/12.webp",document.baseURI+"/images/animation/13.webp",document.baseURI+"/images/animation/14.webp"];y.loadImagesOrdered(r).then(n=>{s.setAnimationData(n)})}),i.addVideoLayer("video",{width:231,height:130,top:0,left:0},new m({autoplay:!0,width:426,height:130,loop:!0,stopOnHide:!0,visible:!1}),{},s=>{const r=document.createElement("video");r.addEventListener("loadeddata",function(){s.setVideo(r)}),r.src=document.baseURI+"/images/transparent-video.webm"}),i.addCanvasLayer("matthew",{width:218,height:91,hAlign:"right",vAlign:"middle",hOffset:-1},{},{},s=>{const r=document.baseURI+"/images/boss-matthew-big.png";fetch(r).then(n=>n.blob()).then(n=>createImageBitmap(n)).then(n=>{s.drawBitmap(n)})}),i.addTextLayer("text1",{width:100,height:17},new m({text:"Scott Pilgrim",left:0,top:0,fontSize:80})),i.addTextLayer("text2",{width:90,height:52,hAlign:"center",vAlign:"middle",hOffset:-60},new m({text:"VS",fontFamily:"Arial",fontSize:100,hAlign:"center",vAlign:"middle",fontStyle:"italic bold",color:"#FFFFFF",renderers:["score-effect"]}),{"score-effect":new T(90,52,200,e)}),i.addTextLayer("text3",{width:90,height:52,hAlign:"center",vAlign:"middle",hOffset:-60},new m({text:"VS",fontFamily:"Arial",fontSize:100,hAlign:"center",vAlign:"middle",fontStyle:"italic bold",color:"#00000000",strokeWidth:2,strokeColor:v.Red})),i.addTextLayer("text4",{width:95,height:15,hAlign:"right",vAlign:"bottom",hOffset:-1},new m({text:"Matthew Patel",fontSize:80})),i.addSpritesLayer("sprite",{width:110,height:130},{},{},s=>{const r=document.baseURI+"/images/scott2x.png";fetch(r).then(n=>n.blob()).then(n=>createImageBitmap(n)).then(n=>{s.createSprite("scott",n,6,0,[{key:"idle",animationParams:{nbFrames:8,width:72,height:118,xOffset:0,yOffset:0,duration:900}},{key:"walk",animationParams:{nbFrames:6,width:72,height:126,xOffset:0,yOffset:118,duration:1100}},{key:"run",animationParams:{nbFrames:8,width:106,height:120,xOffset:0,yOffset:244,duration:650}},{key:"idle2",animationParams:{nbFrames:4,width:92,height:124,xOffset:0,yOffset:364,duration:900}},{key:"taunt",animationParams:{nbFrames:9,width:92,height:124,xOffset:0,yOffset:488,duration:450}}],"2%","2%").then(()=>{const o=[{key:"idle",nbLoop:3},{key:"walk",nbLoop:5},{key:"run",nbLoop:4},{key:"taunt",nbLoop:1}];s.enqueueSequence("scott",o,!0),s.run("scott")})})});const t=document.querySelectorAll("input[type='checkbox']");for(let s=0;s<t.length;s++)t[s].addEventListener("click",function(r){const n=r.target;if(n){const o=n.dataset.layer??"",h=n.checked??!1,d=i.getLayer(o);d!=null?(d.setVisibility(h),h&&o==="sprite"&&d.run("scott")):console.log(`Layer not found : ${o}`)}})})}else alert("Sorry your browser does not support WEBGPU (or the feature is not enabled)")},!1);
